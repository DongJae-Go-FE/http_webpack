/**
 * 캐시가 없을 때
 * 
 * 첫번째 요청
 * 서버에서 헤더와 바디가 합쳐진 용량의 파일을 내려준다.
 * 그후 클라이언트 웹 브라우저에서 그 파일 보여줌
 * 
 * 두번째 요청
 * 서버에서 다시 똑같이 처음처럼 다시 내려준다.
 * 
 * - 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다,
 * - 인터넷 네트워크는 매우 느리고 비싸다
 * - 브라우저 로딩 속도가 늘리다
 * - 느린 사용자 경험
 * 
 * 
 * 
 * 
 * 캐시 적용
 * 첫번째 요청
 * 헤더에 cache-control: max-age=60 // 캐시가 유효한 시간(초) 포함
 * 두번째 요청
 * 그 다음 웹 브라우저에 보여주고 웹 브리우저는 헤더에 저장한 60초를 유효하다는 명령과 함께 브라우저 캐시에 저장을 한다.
 * 
 * - 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
 * - 비싼 네트워크 사용량을 줄일 수 있다.
 * - 브라우저 로딩 속도가 매우 빠르다.
 * - 빠른 사용자 경험
 * 
 * 세 번째 요청 - 캐시 시간 초과
 * 설정한 60초를 초과한 경우 다시 요청을 해야한다.
 * 기존꺼 지우고 응답 결과를 캐시를 저장
 * - 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
 * - 이때 다시 네트워크 다운로드가 발생한다.
 * 
 * 
 * 
 * 
 * 검증 헤더와 조건부 요청
 * 
 * 캐시 시간 초과
 * 
 * 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두가지 상황이 나타난다.
 *  - 서버에서 기존 데이터를 변경함
 *  - 서버에서 가존 데이터를 변경하지 않음
 * 
 * 그런데 서버와 만료된 캐시에 저장된 데이터 값이 똑같을 경우 또 다시 다운 받아야해? 굳이 그럴 필요 없다
 * 
 * 그래서 나온게 검증 헤더와 조건부 요청
 * - 캐시 만료후에도 서버에서 데이터를 변경하지 않음
 * - 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용
 * - 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요
 * - 서버에서 헤더에 Last-Modified: 최종수정일을 헤더에 추가(UTC로 삽입해야함)를 한다음 클라이언트로 쏴주면
 * - 클라이언트는 Last-Modified를 포함해서 브라우저 캐시에 저장을 하는데 웹 브라우저는 if-modified-since: 캐시에 저장된 최종 수정일 을 헤더에
 *   포함에서 서버에 다시 요청을 쏜다.
 * - 어 근데 서버의 최종 수정일이랑 클라이언트의 if-modified-since 날짜가 같은 경우 데이터가 아직 수정되 않았다고 서버에서 확인을 하고
 * - 304 Not Modified 요청으로 HTTP Body 없이 서버에서 클라이언트에게 쏴준다.
 * - 클라이언트는 응답 결과를 브라우저 캐시랑 다시 비교해보고 바뀐게 없다는 걸 알아서 cache-control 시간동안 다시 응답 결과를 재사용, 헤더 데이터 갱신
 * - 그리고 클라이언트 웹 브라우저는 다시 사용
 * 
 * Last-Modified / 검증헤더
 * if-Modified-Since / 조건부 헤더
 * 
 * 정리
 * - 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되 않으면
 * - 304 Not Modified + 헤더 메타 정보만 응답(바디X)
 * - 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
 * - 클라이언트는 캐시에 저장되어 있는 데이터 재활용
 * - 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
 * - 매우 실용적인 해결책
 * 
 * 
 * 
 * 
 * 검증 헤더와 조건부 요청2
 * 
 * 검증 헤더
 *  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
 *  - Last-Modified, ETag
 * 조건부 요청 헤더
 *  - 검증 헤더로 조건에 따른 분기
 *  - if-Modified-Since: Last-Modified 사용
 *  - if-None-Match: ETag 사용
 *  - 조건이 만족하면 200OK
 *  - 조건이 만족하지 않으면 304 Not Modified 
 * 
 * 
 * 
 * if-Modified-Since: 이후에 데이터가 수정되었으면?
 *      - 데이터 미변경 예시
 *          - 캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 10:00:00
 *          - 304 Not Modified, 헤더 데이터만 전송(BODY 미포함) // 너의 캐시로 리다렉션에서 데이터를 뿌려라
 *          - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
 *      - 데이터 변경 예시
 *          - 캐시: 2020년 11월 10일 10:00:00 VS 서버: 2020년 11월 10일 11:00:00
 *          - 200 OK, 모든 데이터 전송(BODY 포함)
 *          - 전송 용량 1.1M(헤더 0.1M, 바디 1.0M)
 * 
 * 
 * 
 * 그런데 검증 헤더와 조건부 요청 / Last-Modified, if-Modified-Since 단점
 *      - 1초 미만(0.x초) 단위로 캐시 조정이 불가능
 *      - 날짜 기반의 로직 사용
 *      - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 더이터가 결과가 똑같은 경우
 *      - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 이런 경우 ETag(엔티티 태그)를 사용
 *          - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우
 * 
 * ETag, if-None-Match
 *  - ETag(Entity Tag)
 *  - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
 *          예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
 *  - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
 *          예) ETag: "aaaa" => ETag: "bbbb"
 *  - 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!
 * 
 * 
 * 
 * 
 * 첫번째 요청
 * 서버에서 헤더에 ETag: "aaaaaa"라고 예시를 들어 클라이언트에 쏴준다
 * 브라우져 캐시는 cache-control: max-age를 포함한 ETag값으 저장
 * 클라이언트 웹 브라우저는 브라우저 캐시에 저장한 ETag값을 if-None-Match에 쏴서 서버에 ETag랑 같을 경우 (데이터가 수정되지 않았다.)
 * 서버는 304 Modified를 쏴주고 HTTP Body가 없이 쏴준다
 * 클라이언트는 다시 캐시 값을 조회해서 쓴다
 * 
 * 
 * 정리
 * - 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기!
 * - 캐시 제어 로직을 서버에서 완전히 관리
 * - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
 * - 예)
 *      - 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지
 *      - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신
 * 
 * 
 * 
 * 캐시와 조건부 헤어
 * - 케시 제어 헤더
 *      - Cache-Control: 캐시 제어
 *              캐시 지시어(directives)
 *                  max-age: 캐시 유효 시간, 초단위
 *                  no-cache: 데이터는 캐시해도 되지만, 항상 원(origin)서버에 검증하고 사용 / 프록시 캐시 확인       
 *                  no-store: 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제) 
 * 
 * 검증 헤더와 조건부 요청 헤더
 *      - 검증 헤더(Validator)
 *          - ETag: "v1.0",ETag: "asid93jkrh2l"
 *          - Last-Modified: Thu, 04 Jum 2020 07:19:24 GMT
 *      - 조건부 요청 헤더
 *          - if-Match, if-None-Match: ETag 값 사용
 *          - if-Modified-Since, if-Unmodified-Since: Last-Modified 값 사용     
 * 
 * 
 * 
 * 
 * 
 * 프록시 캐시
 * 
 * 원 서버 직접 접군
 * 원서버 = origin 서버
 * 
 * 프록시 캐시 서버란?
 * 미국 원 서버로 요청을 클라이언트가 직접 보내면 상당히 오래 걸린다.
 * 그래서 해당 국가에 프록시 캐시 서버라는 경유를 할 수 있는 서버를 둔 뒤 그 서버를 걸쳐서 통해서 보낸다. 이런걸 cdn 서비스라 한다
 * 
 * 클라이언트 웹 브라우저는 private 캐시
 * 프록시 캐시 서버는 public 캐시
 * 
 * Cache-Control: public
 *      - 응답이 public 캐시에 저장되어도 됨
 * Cache-Control: private
 *      - 응답이 해당 사용자만을 위한 것임. private 캐시에 저장해야 함(기본값)
 * Cache-Control: s-maxage
 *      - 프록시 캐시에만 적용되는 max-age
 * Age: 60(HTTP 헤더)
 *      - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)
 * 
 * 
 * 
 * 
 * 
 * 캐시 무효화
 * - 확실한 캐시 무효화 응답 // 웹 브라우저들이 임의 get요청을 캐시하는 경우가 있다
 * 그럴 경우 아래 것을 다 넣어준다. 특히 사용자의 통장잔고 이런거
 *      - Cache-Control no-cache, no-store, must-revalidate
 * 
 *      - Cache-Control: no-cache
 *          - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의!)
 *      - Cache-Control: no-store
 *          - 데이터 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
 *      - Cache-Control: must-revalidate
 *          - 캐시 만료후 최초 조회시 원 서버에 검증해야함
 *          - 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
 *          - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
 * 
 * 
 * no-cache랑  must-revalidate 차이는
 * 순간적으로 프록시 캐시랑 원 서버 통신 오류가 있을 때 노캐시는 프록시 캐시에 예전 데이터를 웹 브라우저에 응답 값으로 보내준다
 *  must-revalidate는 504에러로 처리를 해 보낸다. 통장 잔고 같은 거 과거 데이터를 보내면 말이 안돼
 */